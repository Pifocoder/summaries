# А что если на React?
Я задался таким вопросом, когда решил написать эту работу по физике. Мне хотелось попрактиковаться в React.

## Первая часть
Первоначальной идеей было сделать сайт, в котором пользователь мог ввести параметры броска (угол наклона, стартовая скорость, масса обьекта, коэфицент вязкого трения, коэфицент лобового сопротивления), а сайт промоделировал бы полет этого объекта.

Так как на объект действует несколько сил, я пересчитывал скорость и положение шарика в каждый момент времени, а точнее каждую милисекунду. Я сделал  setInterval на каждую милисекунду, но он дает погрешность, срабатывая  неточно, поэтому каждый раз я брал время в момент срабатывания и вычитал из него время предыдущего срабатывания.
```JS
const updateTime = () => {
   const date = new Date();
   return (
      date.getHours() * 60 * 60 * 1000 +
      date.getMinutes() * 60 * 1000 +
      date.getSeconds() * 1000 +
      date.getMilliseconds()
   );
};
```
Переменные, которые описывают положение и скорость объекта:
```JS
const [objectPositionX, setObjectPositionX] = useState(startPositionX);
const [objectPositionY, setObjectPositionY] = useState(startPositionY);
const [objectSpeedX, setObjectSpeedX] = useState(startSpeedX);
const [objectSpeedY, setObjectSpeedY] = useState(startSpeedY);
```
Начальный(нерабочий) вид пересчета: [код](https://pastebin.com/CYQJJNy2)
Реализован функционал остановки объекта при клике на область. 
**Проблема:** пересчитывать переменные состояния каждую милисекунду не получится, так как setState и setInterval - асинхронные функции,  и значение переменной не успевает измениться к следующему пересчету. 
**Решение**: я добавил переменные без состояния, которые являются полными копиями исходных, теперь на них происходит пересчет в setInterval, а также по ним обновляются состояния исходных, но от их значений зависит положение обьекта на экране пользователя, а не следующий пересчет: [код](https://gitlab.com/Pifocoder/fisiks_throw_bal/-/commit/a6c43148683859f21977c602edb8de8685e83955#d69263f7cb75edec07bd070c3b5219cc8f1da5dc_0_29)
Результат:
![2024 02 01 13 10 03 (online video cutter.com) (1)](https://i.imgur.com/sGTBDne.gif)
Реализация этой [части](https://gitlab.com/Pifocoder/fisiks_throw_bal/-/commit/a6c43148683859f21977c602edb8de8685e83955) 
## Вторая часть
Сайт был бесполезным, поэтому я решил добавить работу с погрешностями. На самом деле каждую милисекунду оъект двигается по прямой:
![IMG 0356](https://i.imgur.com/w7W04Sl.jpeg)
Из-за этого пользователь получает данные о дальности и  максимальной высоте с погрешностью. Я решил добавить пользователю возможность вводить требуемую погрешность, по которой сервис будет выдавать интервалы значений, которые пользователь может ввести в оставшиеся поля. Чтобы это посчитать, я делал бинарный поиск и выдавал подходящий интревал, по невведеному значению. Бинпоиск подходит, потому что погрешность растет, когда объект проводит мало времени в движении, то есть при маленькой скорости или сильном сопротивлении.
Чтобы посчитать корректные значения дальности и максимальной высоты при выбранных параметрах в бинпоиске, я брал выше частоту обновления. Мне не нужно отрисовывать это, поэтому поиск подходящих интервалов работал быстро.
Если пользователь захочет посчитать интервал для скорости, то он должен будет ввести все известные параметры, а мой сервис вернет интревал.
![2024 02 01 13 23 27 (online video cutter.com)](https://i.imgur.com/MGQSWMR.gif)
Код [проекта](https://gitlab.com/Pifocoder/fisiks_throw_bal/-/tree/master?ref_type=heads)
## Итоги
Во время разработки я столкнулся с рядом неочевидных проблем, поэтому этот проект был полезен для меня. Если мне ещё придется писать что-то подобное, то я первым делом напишу нормальный движок, потому что с добавлением нового функционала количество кода слишком быстро росло.