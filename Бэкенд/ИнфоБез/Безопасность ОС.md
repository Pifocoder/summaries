https://attack.mitre.org/ - табличка в которой двигаясь слева направо хакер получает взламывает софт

Атакующий умеет:
1) memfd_create - создание анонимного файла, возвращает файловый дескриптор, который мы сможем дальше использовать в execve. С помощью этой штуки мы может сделать например беспалевную бинарную rce, типа в файле, про который никто не знает.
2) Если на есть фильтрация firewall по tcp, не факт что будет фильтрация по udp/icmp, это можно использовать для подключения к закрытым портам.
3) `echo Privet > /dev/tcp/127.0.0.1/1234` - отправили на самом деле tcp пакет Privet, `/dev/tcp` - виртуальный файл. А Get запрос можно сделать так ![](https://i.imgur.com/YXUTYZb.png)
Как защищаться:
1) убираем очевидные уязвимости
2) детектируем аномальное поведение (osquery)

## LPE
Повышение привелегий
 Разрешения файла:
`drwxr-x--- 7 paulch paulch ....`
1) типа файла (d -дирректория, l - symlink)
2) доступ для пользователя
3) доступ для группы
4) доступ для всех остальных
![](https://i.imgur.com/oFwHJpN.png)

Просто изменение прав для файла и использование утилиты getfacl, для полного просмотра инфы о файлах, потому что в ls мало инфы.
```
$ ls -ld /home/paulch
drwxr-x--- 7 paulch paulch 4096 Nov 12 20:21 /home/paulch/

$ setfacl -m "u: ubuntu: rwx" /home/paulch

$ ls -ld /home/paulch
drwxrwx---+ 7 paulch paulch 4096 Nov 12 20:21 /home/paulch/

$ getfacl /home/paulch
getfacl: Removing leading '/' from absolute path names
# file: home/paulch
# owner: paulch
# group: paulch
user::rwx
user: ubuntu: rwx
group: :r-x
mask::rwx
other::-
```

## passwd
Как утилита passwd меняет пароль, как понимает какому пользователю изменить пароль?
У каждой процесса существует 3 userid: real, effective, saved. Системный вызов, который их меняет называется setresuid и setuid.
1) real - это userid, который говорит, от кого запущена прога, например, если мы просто написала `./main`, то прога запустится от нашего имени (andrey), а если напишем `sudo ./main`, то прога запустится от root.
2) effective - это userid, который говорит, кем мы являемся в процессе выполнение, это чтобы ОС понимала, кто мы на самом деле. Например в процессе работы программы может потребовать нас ввести пароль, чтобы стать root, тогда изенится effective с andrey на root, а real останется прежним - andrey.
3) saved - это userid, который используется для изменения effictive, то есть в процессе исполнения программы ей пришлось в какой то момент выйти из root в нашего пользователя, а потом вернуться обратно, как проверить может ли прога снова стать root, снова спрашивать пароль? ну это бред, поэтому, перед тем как заходить в пользователя, прога сохранить настоящий effictive (т.е. root) в saved и при возвращении(смены effective c andrey на root обратно) ОС как раз проверить этот saved и разрешит вернуться, либо не разрешит)

Сайты на который рассказано как можно использовать suid бит для разных утилит, если он стоит:
1) https://gtfoargs.github.io/
2) https://gtfoargs.github.io/

## Инъекция в соседний процесс
У нас на машине запущеннй какой то прецесс, оказывается если мы удовлетворяем следущим условиям:
![](https://i.imgur.com/Vep5z1I.png)
То мы можем найти pid этого процесса через ps, а потом с помощью gdb к нему подключиться и что то там даже поменять и тд. (ДЛЯ ЭТОГО НЕОБХОДИМ системный вызов ptrace)
Крутая инъекция из лекции: https://github.com/nongiach/sudo_inject
Другая инъекция `/proc/<pid>/mem`

Что можно сделать с помощью process injection:
1) отобрать возможность делать ptrace
2) `/proc/sys/kernel/yama` - контролирует кому можно трейсировать процессы
3) отобрать возможность писать в `/proc/<pid>/mem`

Summary
Повышение привилегий:
1) атаки на привилегированные процессы
	1) через файлы
	2) https://t.me/c/1945183582/987
	3) любой другой ІРС
2) SUID-бинарники
3) процессы другого пользователя
4) атаки на ядро
	1) CVE-2027 -5123
	2) dirty pipe / dirty cow

## **Challenge-Response аутентификация**

**Процесс аутентификации**:

1. **Создание ключей**: Пользователь генерирует пару ключей на своем локальном компьютере (открытый и закрытый ключ).
2. **Размещение открытого ключа**: Открытый ключ загружается на удаленный сервер.
3. **Подключение**: При попытке подключения клиент использует закрытый ключ для создания цифровой подписи.
4. **Проверка сервером**: Сервер проверяет подпись с помощью открытого ключа. Если подпись верна, доступ предоставляется без передачи пароля по сети, что значительно повышает безопасность соединения
5. Сервер генерит рандомный Challenge и отпраляет его клиенту
6. Клиент зашифровывает Challenge и отправляет серверу
7. Сервер расшифровывает и проверяет Challenge.

## Контейнеры
Первая попытка создать контейнер в linux, это просто создать новый корень, попробовать можно командой: 
`sudo debootstrap --variant=minbase --arch=arm64 stable ./fs http://deb.debian.org/debian`
`sudo chroot ./fs/`
Проблема, что в системе после этого в я procfs будут доступны и другие процессы тоже. То есть можно сделать инъекция в лругой процесс.

### Namespaces
Абстракция над глобальными ресурсами системы
![](https://i.imgur.com/JBl2KiC.png)
Из родительского Namespaces мы видим дочерние. 

pivot_root - аналог chroot, который защищает от cd .. из базовой дирректории контейнера.

Полезные системные вызовы:
1) clone - Системный вызов тспользуется для создания новыйх тредов в новых namespaces
2) unshare - системный вызов аналогичный clone
3) setns - перенос текущего процесса в новый namespaces

#### Nginx
Как открыть 80й порт nginx-у,при том, что первые 1234 порта можно открыть только с помощью sudo.
Решение:
1) Открыть порт под root и дать его слушать nginx
2) capabilities - у рута оч много пров, поэтому было решено давть правда рута частями, они выдаются процессу/файловой системе (на стыке)
	1) man capabilities
	2) CAP_DAC_READ_SEARCH - bypass ф.с., открыть файл по i-node, равносильно побегу из контейнера.
	3) `proc/self/status | grep Cap` - посмотреть capabilities процесса
	4) `capsh --decode=00000000a80425fb` - посмотреть расшифровку capability