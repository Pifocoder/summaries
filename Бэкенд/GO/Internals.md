int 
# Массивы
```go
var planets [8]string

arr1 := [3]int{1, 2} // 1, 2, 0
```
 cannot comapare arrays of different lengts
 Массивы передаются по значению
# Slice
```go
initSlice := make([]int, 0, 10) //len = 0, cap = 10
_ = initSlice[0] // panic
```
append - увеличивает len и при необходимости увеличивает cap в 2 раза
```go
cut := initSlice[2:4] //заполненный slice
len(cut) // 2
cap(cut) // 8 - потому что cap расчитывается до последнего элементы из storage(initSlice)
// можем продлить вырезку cut до конца initSlice
cut := cut[:cap(cut)]
```
Slice - это указательна первую ячейку памяти массива, который под ни лежит

Превысим capacity в slice cut:
```go
cut = cut[:cap(cut)]
cut = append(cut, (1 << 10))
cut[0] = 100
fmt.Println(initSlice)// [0 1 2 3 4 5 6 7 8 9]
fmt.Println(cut)// [100 3 4 5 6 7 8 9 1024]
```
 То есть при увеличении cap слайс cut перекопировался в другое место.

Изменение slice в функции
1) Когда мы вызоввем функцию от слайса туда скопирется SliceHeader, то есть указатель на начало слайса и len, cap
2) Изменим слайс (не увеличивая cap)
3) Наш SliceHeader конечно не заметит изменения, потому что мы передавали в функцию копию, но до элементов, которые добавились достучаться сможем
Если же cap увеличится в п.2, то мы не увидим новых элементов нигде, потому что slice будет пересоздан.

Чтобы такого не было надо использовать функцию copy:
```go
sliceCopy := make([]int, len(slice))
copy(sliceCopy, slice)
```

## String
Строка же состоит из указателя на начало и len. при добавлении элемента пересоздается
Например при переделываниии slice в string, string создастся, но выделит не cap байт, а len байт, то есть будет занимать меньше места.

Строки НЕ изменяемые, то есть я не могу изменить строку по индексу.
Надо быть аккуратным с не латинским языком, потому что Нотация `s[i]` возвращает i-й байт в памяти. Этот байт совпадает с символом только в случае однобайтовой кодировки, то есть базовой латинницы.
Чтобы это пофиксить можно привести строку к массиву _рун_ (`rune`) `[]rune(s)`. Этот тип используется в Go для представления юникодных символов в 4-х байтовой кодировке.