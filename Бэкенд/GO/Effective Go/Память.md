Выражения `new(File)` и `&File{}` ***эквивалентны***  
## Модель памяти
В работе с памятью одну из ключевых ролей играет выбранный аллокатор. В Go с памятью работает собственный аллокатор, основанный на tcmalloc. Одна из его особенностей — предсказуемая фрагментация. В зависимости от размера переменная может попасть в один из заранее определенных классов размеров.  
  
В go-аллокаторе, в отличие от нативного tcmalloc, существует три варианта распределения: тини, смол и лардж. Лардж применяется для объектов размером более 32 байт. Смол для объектов менее 32 байт и более 16 байт. Ну и тини — для тех, что просто менее 16 байт.  
  
Особенность тини-аллокатора в том, что он пытается скомпоновать в один спан (8 или 16 байт, первые 2 класса-размера) как можно больше объектов меньшего размера, соблюдая при этом правила выравнивания. Так, например, простой int64, имея размер 8 байт, целиком помещается в первый класс-размер, занимая его полностью. Две переменные int32, 4 байта каждая, также попадут в первый класс-размер и вполне могут быть упакованы в один спан.  
  
А вот массив из 17 byte попадет в третий класс-размер, и им уже займется смол-аллокатор. И хотя третий класс-размер позволяет хранить объекты размером до 32 байт, объект на 17 байт займет его полностью. Оставшиеся 15 незанятых байтов будут потеряны — что и есть та самая управляемая фрагментация.

Функция для печать памяти
```go
func PrintAsBinary(a any) {
   type iface struct {
      t, v unsafe.Pointer
   }
   p := uintptr((*(*iface)(unsafe.Pointer(&a))).v)

   t := reflect.TypeOf(a)

   for i := 0; i < int(t.Size()); i++ {
      n := *(*byte)(unsafe.Pointer(p))
      fmt.Printf("%08b ", n)
      p += unsafe.Sizeof(n)
   }

   fmt.Print("\n")
}
```

распечатаем память, 32768 — это двойка в пятнадцатой степени,результат 0..0 10..0, байты идут в обратном порядке
```go
func main() {    
	var x uint16    
	x = 32768    
	PrintAsBinary(x)
}
```

## Структуры 
В структурах есть выравнивание, поэтому располагать элементы в них надо с умом.
```go
type alignmentStruct12 struct {
    b1 byte
    i  uint32
    b2 byte
}

func main() {
    x := alignmentStruct12{
        b1: util.MaxByte,
        i:  util.MaxUint32,
        b2: util.MaxByte,
    }

    fmt.Println(unsafe.Sizeof(x))
    fmt.Println(*(*[12]byte)(unsafe.Pointer(&x)))
}
```
```
12
[255 0 0 0 255 255 255 255 255 0 0 0]
```
```go
type alignmentStruct8 struct {    
	i  uint32    
	b1 byte    
	b2 byte
}
```
```
8
[255 255 0 0 255 255 255 255]
```
Общее правило может звучать как «сортируйте поля в ваших» структурах по размеру. При этом не имеет особой разницы по возрастанию или по убыванию будут отсортированы поля — на конечный размер структуры это не повлияет. Правильнее сортировать по цбыванию.
В Go используется **«требуемое выравнивание»**. Его значение равно размеру памяти, требующемуся самому большому полю в структуре. То есть, если в структуре есть только поля int32 , то «требуемое выравнивание» составит 4 байта
## Интерфейсы
Таким же образом мы можем заглянуть и внутрь пойнтера на тип. Но там все немного сложнее, поскольку тип представляет собой еще одну, уже не такую простую, структуру itab. При желании вы всегда можете самостоятельно получить гораздо больше информации напрямую из кода рантайма: [https://go.dev/src/runtime/runtime2.go](https://go.dev/src/runtime/runtime2.go)
## Map
```
type hmap struct {
  count     int
  flags     uint8
  B         uint8
  noverflow uint16
  hash0     uint32

  buckets    unsafe.Pointer
  oldbuckets unsafe.Pointer
  nevacuate  uintptr
}
```
https://go.dev/src/runtime/map.go