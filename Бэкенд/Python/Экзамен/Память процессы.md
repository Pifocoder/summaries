is - сравнивает id() обектов, т е указывают ли они на одну и ту же память
`==` сравнивает значения объектов, является синтаксическим сахаром `a.__eq__(b)`

```python
from functools import lru_cache

id = lru_cache(id)

# cache = {}
# def id(key):
#    if key in cache:
#        return cache[key]
#    value = id(key)
#    cache[key] = value
#    return value


id(__builtins__) == id(builtins) # True

```

Переменные (ссылки на объекты) хранятся в stack.
Объекты хранятся в heap.
Подсчет ссылок - каждый объект имеет счетчик ссылок. Когда он становится равным 0, память освобождается для повторного использования.
GC использует технику mark-and-sweep для удаления циклических ссылок:
маркировка: GC проходит по графу объектов, помечая все достижимые объекты;
очистка: проходит по немаркированным объектам, выявляя циклы и собирая их.

`psutil` — это библиотека Python для получения информации о системных процессах и использовании ресурсов:
```python
import psutil

print(f"CPU Usage: {psutil.cpu_percent(interval=1, percpu=False)}%")
```
`psutil.virtual_memory()` - оператива + немного на диске.
`psutil.swap_memory()` - часть виртуальной памяти, которая находится на диске
`psutil.disk_usage(path)`

В Google Colab объект `psutil.Process()` относится к текущему Python-процессу, который выполняется в среде Colab
```python
p = psutil.Process()
p.memory_info()
```
rss - сколько занимает процесс в ram
vms - сколько занимает процесс в вирт
data - Объем памяти, используемой для хранения данных (например, переменные программы).

**Файл дампа памяти** (`core file`) — это специальный файл, который создается OS в момент аварийного завершения программы
`RLIMIT_CORE`: max размер (в байтах) файла дампа памяти (`core file`),
```python
import resource

# Получаем текущие лимиты на размер core-файла
soft_limit, hard_limit = resource.getrlimit(resource.RLIMIT_CORE)

print(f"Мягкий лимит на размер core-файла: {soft_limit} байт")
print(f"Жёсткий лимит на размер core-файла: {hard_limit} байт")
```
```python
import resource

# Получаем текущие лимиты на размер стека
soft_limit, hard_limit = resource.getrlimit(resource.RLIMIT_STACK)

print(f"Мягкий лимит на размер стека: {soft_limit} байт")
print(f"Жёсткий лимит на размер стека: {hard_limit}")
```
 **RLIMIT_DATA** - Максимальный размер сегмента данных процесса (включает инициализированные и неинициализированные данные, а также кучу).
**RLIMIT_RSS** - Максимальный размер резидентного набора (RSS), который может использовать процесс (в байтах).
**RLIMIT_AS** - Максимальная область адресного пространства, которую может занимать процесс (в байтах).
**RLIMIT_NPROC** - Максимальное количество процессов (или потоков), которые могут быть созданы вызывающим процессом.
**RLIMIT_MEMLOCK** - Максимальный объем памяти, который может быть заблокирован в RAM (в байтах).
**RLIMIT_CPU** - Максимальное количество процессорного времени (в секундах), которое может использовать процесс.

Поля, возвращаемые `resource.getrusage()`:
1. **`ru_utime`**: - Время, затраченное на выполнение в пользовательском режиме (в секундах).
2. **`ru_stime`** - Время, затраченное на выполнение в системном режиме (в секундах).
3. **`ru_maxrss`** - Максимальный размер резидентной памяти (в килобайтах).
4. **`ru_ixrss`** - Размер общей памяти (в килобайтах).
5. **`ru_idrss`** - Размер неразделяемой памяти (в килобайтах).
6. **`ru_isrss`** - Нераспределенный размер стека (в килобайтах).
7. **`ru_nswap`** - Количество выходов подкачки.
8. **`ru_inblock`** - Блочные операции ввода.
9. **`ru_oublock`** - Блочные операции вывода.
10. **`ru_msgsnd`**- Количество отправленных сообщений.
11. **`ru_msgrcv`** - Количество полученных сообщений.
12. **`ru_nsignals`**- Количество полученных сигналов.
13. **`ru_nvcsw`**- Добровольные переключения контекста.
14. **`ru_nivcsw`** - Непроизвольные переключения контекста.

### Processes v/s Threads

| Критерий                  | Processes (Процессы)                         | Threads (Потоки)                                    |
| ------------------------- | -------------------------------------------- | --------------------------------------------------- |
| **Память**                | Имеют собственное адресное пространство      | Разделяют общее адресное пространство               |
| **Создание**              | Тяжеловесные, требуют больше ресурсов        | Легковесные, быстро создаются                       |
| **Изоляция**              | Изолированы от других процессов              | Менее изолированные, возможен доступ к общей памяти |
| **Взаимодействие**        | Требуется межпроцессное взаимодействие (IPC) | Легкий обмен данными через общую память             |
| **Стабильность**          | Сбой в процессе не влияет на другие процессы | Сбой в потоке может привести к сбою всего процесса  |
| **Использование**         | Отдельные программы или сервисы              | Параллельные задачи внутри одного приложения        |
| **Контекст переключения** | Более затратен при переключении контекста    | Менее затратен при переключении контекста           |
`resource.getpagesize()` возвращает размер страницы памяти в байтах, используемой OS. Размер страницы определяет минимальную единицу памяти, которую может выделить или OS.

 `tracemalloc` - дает возможность отслеживать потребление памяти
```python
tracemalloc.start()
current, peak = tracemalloc.get_traced_memory()
snapshot = tracemalloc.take_snapshot() # снимок используемой памяти дл анализа
tracemalloc.stop()
```
`snapshot.statistics(key_type, cumulative)`

| **Параметр**                      | **Описание**                                                                             | **Когда использовать**                                                                                            |
| --------------------------------- | ---------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------- |
| `key_type='filename'`             | Группирует статистику по имени файла, где произошло выделение памяти.                    | Для быстрого анализа, какие файлы вызывают наибольшее выделение памяти.                                           |
| `key_type='lineno'`               | Группирует статистику по имени файла и номеру строки, где произошло выделение памяти.    | Для более детального анализа, чтобы понять, на каких строках кода происходит выделение памяти.                    |
| `key_type='traceback'`            | Группирует статистику по полному стеку вызовов (traceback), ведущему к выделению памяти. | Для поиска сложных утечек памяти или анализа цепочек вызовов, связанных с выделением памяти.                      |
| `cumulative=False` (по умолчанию) | Учитывает только последний кадр стека вызовов, где произошло выделение памяти.           | Для определения точного места в коде, где было выделение памяти.                                                  |
| `cumulative=True`                 | Учитывает память всех кадров стека вызовов (traceback), а не только последнего.          | Для анализа общей нагрузки на память по всей цепочке вызовов. Работает только с `key_type='filename'` и `lineno`. |
 `snapshot2.compare_to(snapshot1, 'lineno')`

del vs `__del__`:
1. Когда вы создаете объект в Python, он получает счетчик ссылок, который отслеживает количество ссылок на него.
2. При использовании оператора `del` количество ссылок уменьшается на 1.
3. Когда счетчик ссылок достигает нуля (т.е. ни одна переменная больше не ссылается на объект), вызывается метод `__del__`, если он определен.
4. После вызова метода `__del__`, память, занимаемая объектом, освобождается.
## GC
Алгоритм подсчета ссылок выполняется в главном потоке программы. Он встроен в ядро интерпретатора CPython и не требует отдельных потоков или процессов.
Сборщик мусора разделяет объекты на три поколения (0, 1, 2) в зависимости от их "возраста" (сколько сборок они пережили). Новые объекты попадают в поколение 0. Если объект выживает сборку, он перемещается в более старшее поколение.
Пороги gc: как только количество выделение - количество освобождений превышает порог, запускаяется gc для этого поколения.

1. **`gc.get_stats()`**
    - **Описание**: Возвращает статистику по сборке мусора для каждого поколения, включая количество собранных объектов (`collected`) и количество объектов, которые не могут быть собраны (`uncollectable`).
2. **`gc.enable()`**
    - **Описание**: Включает автоматическую сборку мусора.
3. **`gc.disable()`**
    - **Описание**: Отключает автоматическую сборку мусора.
4. **`gc.isenabled()`**
    - **Описание**: Проверяет, включена ли автоматическая сборка мусора.
5. **`gc.collect(generation=2)`**
    - **Описание**: Запускает процесс сборки мусора для указанного поколения (0, 1 или 2). По умолчанию собираются все поколения.
6. **`gc.set_debug(flags)`**
    - **Описание**: Устанавливает флаги отладки для сборщика мусора, которые могут включать:
        - `gc.DEBUG_STATS`: Печатает статистику сборки.
        - `gc.DEBUG_COLLECTABLE`: Показывает объекты, которые могут быть собраны.
        - `gc.DEBUG_UNCOLLECTABLE`: Показывает объекты, которые не могут быть собраны.
        - `gc.DEBUG_SAVEALL`: Сохраняет все объекты при отладке.
        - `gc.DEBUG_LEAK`: Помогает обнаружить утечки памяти.
7. **`gc.get_debug()`**
    - **Описание**: Возвращает текущие флаги отладки для сборщика мусора.
8. **`gc.get_objects(generation=None)`**
    - **Описание**: Возвращает список всех объектов, отслеживаемых сборщиком мусора. Можно указать поколение для фильтрации.
9. **`gc.get_count()`**
    - **Описание**: Возвращает кортеж с количеством выполненных сборок мусора для каждого поколения.
10. **`gc.get_referrers(*objs)`**
    - **Описание**: Возвращает список объектов, ссылающихся на указанные объекты.
11. **`gc.get_referents(*objs)`**
    - **Описание**: Возвращает список объектов, на которые ссылаются указанные объекты.
12. **`gc.is_tracked(obj)`**
    - **Описание**: Проверяет, отслеживается ли указанный объект сборщиком мусора.
13. **`gc.is_finalized(obj)`**
    - **Описание**: Проверяет, был ли объект финализирован (т.е., вызван метод `__del__`).
14. **`gc.freeze()`**
    - **Описание**: Замораживает состояние сборщика мусора, предотвращая дальнейшие изменения в его работе.
15. **`gc.get_freeze_count()`**
    - **Описание**: Возвращает количество замороженных объектов в текущий момент времени.
16. **`gc.unfreeze()`**
    - **Описание**: Размораживает состояние сборщика мусора, позволяя ему снова работать.
17. **`gc.callbacks`**
    - **Описание**: Список функций обратного вызова, которые будут вызваны перед и после выполнения сбора мусора.
18. **`weakref`**
    - **Описание**: Модуль предоставляет поддержку слабых ссылок на объекты Python, которые не увеличивают счетчик ссылок на объект и позволяют ему быть собранным сборщиком мусора.
```python
import weakref

class MyClass:
    def __init__(self, name):
        self.name = name

def on_finalize(weak_ref):
    print(f"Объект {weak_ref} был удалён.")

# Создание объекта
obj = MyClass('CallbackExample')

# Создание слабой ссылки с коллбеком
weak_obj = weakref.ref(obj, on_finalize)

# Удаление сильной ссылки
del obj
```