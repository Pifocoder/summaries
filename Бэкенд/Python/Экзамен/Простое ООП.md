**Класс – формочка для печенья, объект — печенье.**
@classmethod - декоратор, который дает возможность методу изменять атрибуты класса, на вход получает не self, а cls, а также писать фабричные матоды. 
@staticmethod - декоратор для обычных ыункций связанных с классом, которым не нужен доступ к атрибутам или методам класса.
фабричные методы - методы, которые создают новый экземпляр класса.

Переменные в питоне - это ссылки на область в памяти, поэтому при присваивании просто копируется ссылка.
mutable - изменяемые (массивы, **dict**, set, **bytearray**)
immutable - не изменяемые (**int**, float, complex, str, tuple, frozenset)

В python хэшируются только неизменяемые типы, а также объекты, которые поддерживают метод `__hash__()`.

| Функция  | Назначение                                            | Возвращаемое значение       | Применимость         |
| -------- | ----------------------------------------------------- | --------------------------- | -------------------- |
| `hash()` | Получение хэш-значения объекта                        | Целое число (хэш)           | Неизменяемые объекты |
| `id()`   | Получение уникального идентификатора объекта в памяти | Целое число (идентификатор) | Все объекты          |
hex просто кодирует id в формат hex.
hash используется в сравнение неизменяемых объектов.
dunder methods: `__init__`, `__repr__` v/s `__str__`, `__len__`, `__call__`, `__add__`, `__sub__`, `__mul__`, `__truediv__`, object и причём тут 'Сахар'?
## Инкапсуляция

| public    | self.attribute   | Доступно в любом месте                                                                                |     |
| --------- | ---------------- | ----------------------------------------------------------------------------------------------------- | --- |
| protected | self._attribute  | Предназначено для использования внутри класса и его подклассов                                        |     |
| private   | self.__attribute | Недоступно извне родительского класса напрямую.  <br>Использует name mangling (_ClassName__attribute) | **  |
name mangling - доcтуп к приватному аттрибуту извне
```python
print(account._BankAccount__balance) # Попытка доступа к приватному атрибуту извне
```
геттеры и сеттеры - принцип, когда для изменения переменных класса используются  сеттеры, чтобы например проверить на корректность новое значение.
Декоратор `@property` позволяет автоматически создавать геттеры и сеттеры для атрибутов класса, избавляя от необходимости явно вызывать методы с помощью круглых скобок. Это делает код более чистым и удобным для чтения.
```python
class Circle:
    def __init__(self, radius):
        self._radius = radius  # Приватный атрибут

    @property
    def radius(self):
        """Геттер для получения значения радиуса."""
        return self._radius

    @radius.setter
    def radius(self, value):
        """Сеттер для установки значения радиуса."""
        if value < 0:
            raise ValueError("Радиус не может быть отрицательным.")
        self._radius = value
circle = Circle(5)
print(circle.radius)  # Вызов геттера без круглых скобок

circle.radius = 10    # Вызов сеттера без круглых скобок
print(circle.radius)  # Теперь радиус равен 10
```

## Наследование
super - это родитель в mro цепочке.
```python
class A:
    def method(self):
        print("Method from A")

class B(A):
    def method(self):
        print("Method from B")
        super().method()

class C(A):
    def method(self):
        print("Method from C")
        super().method()

class D(B, C):
    def method(self):
        print("Method from D")
        super().method()

d = D()
d.method()
```
super - класс родитель
```python
class Person:
    def __init__(self, name):
        self.__name = name

    @property
    def name(self):
        return self.__name

class Employee(Person):
    def __init__(self, name, company):
        super().__init__(name)
        self.__company = company

    @property
    def name(self):
        return f"{self.__name}, работает в {self.__company}"

# Пример использования
employee = Employee("Иван", "ООО Ромашка")
print(employee.name)  # Выводит: Иван, работает в ООО Ромашка
```

`__dict__` - словарь: атрибут экземпляра класса и его значение.
`dir()` -  возвращает список всех атрибутов и методов объекта.
`vars()` - аналогичен `__dict__`, если объект не передан, она возвращает словарь текущего локального пространства имен (аналогично `locals()`)

help - возвращает строку, т е доку, 
`__class__` - ссылается на класс объекта.
