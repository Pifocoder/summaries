LEGB - Local, enclosed, global, builtin
**Scope** (область видимости) — это контекст, в котором доступна переменная, тогда как **namespace** (пространство имен) — это контейнер для имен.
global, nonlocal - обявление переменный из global или enclosed scope.

globals() locals() - выводит соответствующие namespaces
**dir()**: Показывает список имен в текущем пространстве имен.

**Python определяет области видимости переменных во время компиляции функции, а не во время выполнения.**

`if __name__ == '__main__'`
Эта конструкция позволяет определить, выполняется ли модуль как основная программа или импортируется как модуль.

`__code__` - позволяет посмотреть внутрянку функции, например переменные, которые она юзает: `func.__code__.co_varnames`

Оператор "морж" в Python, формально известный как оператор присваивания выражения `:=`, был введен в версии 3.8. Он позволяет одновременно присваивать значение переменной и возвращать это значение в одном выражении.
## Замыкание
```python
def mean():
    sample = []  # возможна "утечка" памяти -- сложно отследить
    def _mean(number):
        sample.append(number)
        # print(locals())
        return sum(sample) / len(sample)
    return _mean

current_mean = mean()
print(current_mean(10))
```
`current_mean.__code__.co_code`  byte-code функции
`print(current_mean.__code__.co_freevars)` - кортеж с именами (свободных) переменных полученных из внешнего `scope`
```python
sample_cell = current_mean.__closure__[0]
sample_list = sample_cell.cell_contents
print(sample_list)
```
Можно смотреть `sample_list` в динамике.
Аргументы по умолчанию часто используятся в замыканиях (При создании функций внутри цикла, которые замыкают переменные цикла, необходимо обеспечить, чтобы каждая функция замыкала значение переменной на момент создания функции.):
```python
def create_multipliers():
    multipliers = []
    for i in range(5):
        def multiplier(x, i=i):  # Захватываем текущее значение i
            return i * x
        multipliers.append(multiplier)
    return multipliers

# Тестируем функцию
multipliers = create_multipliers()
for m in multipliers:
    print(m(2))
```

## import
`__init__.py` - это специальный файл, который нужно помещать в директорию, чтобы Python распознавал её как пакет. 
`__all__` - это список, объявленный в модуле, который определяет, какие сущности должны быть доступны при использовании `from module import *`. 

Абсолютный импорт : `from package.module import ...`. Относительный импорт: `from .module import ...`. Модули и библиотеки в Python хранятся в каталогах, указанных в `sys.modules`,

APT - Используемые библиотеки хранятся в кэше по пути `/var/cache/apt/archives/`.
`apt.Cache()` - создает объект кэша
`cache.update()`  - обновляет информацию о пакетах (`apt update`)

Для просмотра локации модуля во время выполнения (Runtime) можно использовать `module_name.__file__`
`__pycache__` - это каталог, в котором Python хранит скомпилированные версии модулей (файлы с расширением `.pyc`),
`pip` и `gcc` - это инструменты для установки Python-пакетов и компиляции C-расширений соответственно.
`p`pip install module_name --no-cache-dir` устанавливает модуль без использования кэша.ip install module_name --no-cache-dir` устанавливает модуль без использования кэша.

`usr/bin` - для исполняемых файлов
`usr/lib` - cодержит библиотеки — вспомогательные файлы
`usr/libexec` - исполняемые файлы библиотек,  вспомогательные программы
`usr/local` - локальные пакеты, установленные отдельно от системы
`usr/share` - общие данные для приложений

`!cd /usr/lib && ls -A | grep py`
```
python2.7
python3
python3.10
python3.11
```
- `python3`  содержит конфигурационные и вспомогательные файлы, доступные для всех версий Python 3
- `/python3/dist-packages` - являются частью дистрибутива и поддерживаются разработчиками ОС
- `python3.X` - содержит стандартные модули и библиотеки Python 3.X (например, `os`, `sys`, `math`).
- `/usr/local/lib/python3.10/dist-packages` - пакеты установленные через pip пользователем
Если один и тот же пакет установлен в обеих директориях, Python будет использовать версию из /usr/local/lib, что позволяет пользователю переопределять системные пакеты.
```python
import builtins
import importlib

# Сохраняем ссылку на встроенную функцию print
original_print = builtins.print

# Удаляем встроенную функцию print
del builtins.print

# Проверяем, что print больше не доступен
try:
    print("Это не должно сработать")  # Это вызовет NameError
except NameError as e:
    original_print(f"Ошибка: {e}")  # Используем сохраненную ссылку на print

# Реимпортируем builtins
import sys

# Удаляем ссылку на builtins из sys.modules
if 'builtins' in sys.modules:
    original_print("sys")
    del sys.modules['builtins']

# Теперь реимпортируем builtins
builtins = importlib.import_module('builtins')

# Теперь встроенная функция print доступна снова
builtins.print("asd")  # Это будет работать, так как мы реимпортировали builtins
```
## SYS
`sys.argv` — список, содержащий аргументы командной строки
`sys.exit([arg])` завершает выполнение программы.
`sys.path` — список строк, определяющих пути, по которым Python ищет модули для импорта.
- `sys.version` — строка, содержащая информацию о версии Python
- `sys.version_info` — кортеж, содержащий детализированную информацию о версии Python
- `sys.platform` — строка, указывающая на платформу, на которой запущен интерпретатор Python.
- `sys.modules` — словарь в модуле `sys`, который хранит все загруженные модули и подмодули в текущем сеансе интерпретатора Python. Ключами этого словаря являются имена модулей, а значениями — объекты модулей.
```python
%%writefile _my_module.py
print('_my_module is here')
```
Основная функция `sys.modules`: **кэширование импортированных модулей**:

`math` — встроенный модуль на языке `C`, не имеющий соответствующего `.py` файла, как у обычных пользовательских модулей Вместо этого он включён в бинарный файл интерпретатора Python.

- `sys.stdout` — стандартный поток вывода.
- `sys.stderr` — стандартный поток ошибок: позволяет отделить обычный вывод от сообщений об ошибках.
- `sys.stdin` — это поток, из которого программа читает ввод пользователя. Обычно используется для получения данных от пользователя через консоль.
- `sys.getsizeof(object)` — возвращает размер объекта в байтах + память на накладные рассходы:

- **`__sizeof__()`**: Возвращает размер только самого объекта, без учета дополнительных ссылок на другие объекты, которые он может содержать.
- `sys.getrefcount(object)` — возвращает количество ссылок на объект.
(!) Важно знать, что вызов этой функции увеличивает счетчик ссылок на объект на 1.
`Out` — это специальный словарь в Jupyter Notebook, который хранит выводы всех ячеек с момента запуска ядра. Каждый результат, который выводится из ячейки (например, результат вычисления или объект), автоматически сохраняется в `Out` и доступен через его индекс, соответствующий номеру запуска ячейки.


Модуль `builtins` в Python предоставляет доступ ко всем встроенным идентификаторам, таким как функции и исключения. 
Модуль `__builtin__`
В Python 2 существовал модуль `__builtin__`, который также предоставлял доступ к встроенным функциям и объектам. В Python 3 этот модуль был заменен на `builtins`.
Переменная `__builtins__` доступна в глобальном пространстве имен и обычно ссылается на модуль `builtins`. 

```python
import some_module 
print(some_module.__version__)
```
pip show some_module

## Файлы и директории
- **`__init__.py`**: Этот файл используется для обозначения директории как пакета Python. Он может быть пустым или содержать код для инициализации пакета.
- **`__all__`**: Это список строк, который определяет, какие атрибуты будут импортированы при использовании команды `from package import *`.
- **`__doc__`**: Этот атрибут содержит строку документации для модуля или пакета.
- **`__annotations__`**: Этот атрибут хранит аннотации типов для переменных и функций.